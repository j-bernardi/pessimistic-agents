
def main():

    # pick int (from prior? tbc if geometric dist is appropriate)
    # turn the int into a bitstring and then into a list of boundaries.

    # initialize agent
        # pick world models until sum weight = beta

    # run loop

        # find optimal point
        # move to (towards seems redundant) optimal point
        # if optimal point is past the real world model we ded
        # now we're stuck
        # we ask the mentor?
            # work out distribution over mentor policies
            # expected value of mentor policy
        # if we ask the mentor and it gives us a point which is beyond a boundary then we get rid of that boundary
        # and re-pick world models until sum weight = beta
    
        # if we don't ask the mentor we end the loop.
    


    pass
    

def viz(n_boundaries=50):

    pass




if __name__ == "__main__":
    main()
